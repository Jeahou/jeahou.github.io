---
title:  "알고리즘 두번째테스트"

categories:
  - algolism
tags:
  - 알고리즘
last_modified_at: 2021-03-04T18:10:00-05:00
---

> [백준 10870번](https://www.acmicpc.net/problem/10870) 를 풀면서 피보나치 수열 구하기를 두 가지 방법으로 풀어보았다!
>
> ❔ 피보나치 수열이란?
> 어떤 수열의 원소를 0번째부터 볼 때, 0번째 수는 0, 1번째 수는 1 이고, 2번째 수 부터는 n-1번째 수 + n-2번째 수를 만족하는 수열을 피보나치 수열이라고 한다. 

<br>

## 🏢 동적계획 알고리즘으로 푸는 방법
---

- 동적계획 알고리즘이란?

	> 학교 알고리즘 수업을 통해 동적계획 알고리즘의 작동 방식에 대해서 배우게 되었다. 

	영어로 Dynamic Programming 이라고 하여 줄여서 DP 알고리즘이라고도 부른다.

	간략히 설명하자면 동적계획 알고리즘은 문제의 해를 구하기 위해 문제를 작은 단위로 쪼갠다. 그리고 이 작은 단위 문제들의 해들을 미리 구해 배열에 저장해놓은 후, 원래 문제를 풀 때 배열에 저장되어 있는 값들을 사용하는 방식으로 작동하는 알고리즘이다.

	<br>

- 피보나치 수열 구하기 코드

	~~~c
	#include<stdio.h>

	int main(){
		int n;
		int f[20];  
		f[0] = 0, f[1] = 1;
		scanf("%d", &n);
	
		for(int i = 2 ; i <= n ; i++){
			f[i] = f[i-1] + f[i-2];
		}
	
		printf("%d", f[n]);
	}
	~~~

	<br>

	위 코드를 보면 배열 f[20]에 피보나치 수열의 값들을 계속 저장시키는 모습을 볼 수 있다. 

	이 때, for문 안의 코드를 보면 피보나치에서 사용되는 n-1번째, n-2번째 값들을 배열에서 가져와 사용하는 것을 볼 수 있다. 

	<img src = "https://user-images.githubusercontent.com/31889335/59999639-72b4e380-969d-11e9-81d7-c2ab02fbf6dc.PNG" >

	<br>

	또한, for 문에서 i 가 2부터 n 까지 증가하는데 이것이 원래 문제를 해결하기 위해서 문제를 작은 단위로 나눈 것이 된다. 즉, for문의 i 가 2일 때는, 피보나치 수열을 0번째부터 2번째까지 구하는 작은 문제인 것이고, for문의 i가 3일 때는, 피보나치 수열을 0번째부터 3번째까지 구하는 작은 문제가 되는 것이다.

	이렇게 작은 문제들이 점점 큰 문제로 바뀌면서 최종 문제의 해까지 도달하는 것이다!!

	동적 계획 알고리즘으로 피보나치 수열을 푼 것을 찬찬히 생각해보면 __상향식(bottom-up)__ 으로 값이 구해진다는 것을 알 수 있다. 즉, 원하는 값을 구하기 위해 작은 값부터 구하며 위로 올라오는 방식이다.

	<br>
